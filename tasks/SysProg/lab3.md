# Задание по системному программированию: Клиент-серверное приложение на C++
## Цель работы
Разработать устойчивое и модульное клиент-серверное приложение на C++20 с использованием TCP и межпроцессного взаимодействия (IPC), с полной инкапсуляцией системных вызовов и соблюдением современных принципов организации кода.

## Архитектура приложения
Приложение состоит из следующих компонентов:

- Клиент — подключается к серверу по TCP-сокету и отправляет команды.

- Основной сервер — обрабатывает подключения и взаимодействует с подсервером в зависимости от команды.

- Два подсервера (в виде отдельных процессов):

    - Подсервер компиляции (.cpp или .tex).

    - Подсервер игры "Палочки".

## Функционирование подсерверов

- Подсервер компиляции — получает на вход от клиента один файл и, в зависимости от его расширения, производит компиляцию в исполняемый или pdf файл для расширений cpp и tex соответственно. После завершения работы возвращает пользователю скомпилированный файл.

- Подсервер игры — получает от клиента сообщение с количеством забираемых палочек, в ответ отправляет либо количество забранных сервером палочек, либо сообщение о победе или поражении клиента. [Ссылка](https://ru.wikipedia.org/wiki/Баше_(игра)) с пояснением.

## Протокол взаимодействия

- Обмен данными между клиентом и сервером осуществляется по TCP-соединению.

- IPC между сервером и подсервером компиляции:

    - Разделяемая память + Семафоры.

    - Очередь компиляции общая для всех пользователей.

- IPC между сервером и подсервером игры:

    - Очередь сообщений (System V).

    - Отдельная игровая сессия для каждого клиента.

## Требования к реализации
1. Язык реализации:
    - C++ не ниже стандарта C++20.

2. Структура проекта:

    - Каждый компонент (клиент, сервер, оба подсервера и утилиты) должен располагаться в отдельной папке, содержащей:

        - src/ — исходные файлы (.cpp).

        - include/ — заголовочные файлы (.hpp).

        - CMakeLists.txt — локальный файл сборки.

3. Сборка:

    - Все исполняемые файлы должны собираться с использованием корневого CMakeLists.txt файла с флагами "-std=c++20 -Wall -Wextra -Wpedantic -Werror -fsanitize=address -fsanitize=leak" без ошибок и предупреждений.

4. Инкапсуляция:

    - Все системные вызовы должны быть инкапсулированы в C++ классы.

    - Запрещены прямые вызовы C API в логике приложения.

5. Память:

    - Запрещено использовать "сырые" указатели и операции new/delete.

    - Использовать только умные указатели (std::shared_ptr, std::unique_ptr).


6. Обработка ошибок:

    - Все исключительные ситуации должны быть обработаны с использованием пользовательских или стандартных классов исключений.

    - Программа должна корректно обрабатывать:

        - Неверные команды.

        - Потерю соединения с клиентом.

        - Ошибки IPC.

7. Логгирование:

    - Все действия (подключения, ошибки, события IPC и пр.) логируются с помощью Logger из лабораторной №2.

8. Параллелизм и устойчивость:

    - Сервер поддерживает многопользовательскую работу.

    - Обработка данных от каждого клиента происходит в отдельном потоке.

    - Подсервер игры реализует изолированную сессию на клиента.

    - Все компоненты работают стабильно при сбоях.

9. Завершение работы:

    - Сервер корректно закрывает все подключенные к нему соединения и освобождает иные занятые им ресурсы.

    - Клиент оповещает сервер о завершении сессии и освобождает занятые им ресурсы.

## Рекомендации

1. При работе с TCP использовать ранее реализованный протокол передачи данных: сначала размер, потом сами данные.

2. В качестве шаблона для лабораторной работы использовать данный [пример](https://github.com/SkiStalker/FundAlg3Sem/tree/main/examples/SysProg/Lab3).

3. При работе с потоками использовать класс std::thread из stl.