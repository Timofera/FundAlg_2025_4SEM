# Лабораторная работа №3

## Общие требования

* Все задания реализуются на языке программирования C++ (стандарт C++17 и выше).
* Запрещено использование глобальных переменных (включая `errno`).
* Запрещено использование оператора безусловного перехода (`goto`).
* Запрещено использование функций, завершающих выполнение программы вне `main`.
* При реализации необходимо отделять алгоритмическую часть от ввода/вывода.
* Все вводимые данные должны проходить проверку на корректность.
* Необходимо корректно освобождать всю выделенную динамическую память.
* Все ошибки, связанные с операциями ввода-вывода, должны быть обработаны.
* Код должен соответствовать принципам SOLID и паттерну *Стратегия* для компараторов.
* Запрещено использовать функции стандартной библиотеки языка C, если есть аналоги в C++.
* Оформление кода должно соответствовать `clang-format`.
* Код должен быть проверен с использованием `cppcheck`.

## О сборке

1. Каждое задание должно находиться в отдельной папке.
2. Проект должен собираться с использованием CMake (версии 3.10 и выше).
3. Структура проекта должна содержать директории:

   * `src/` — исходный код
   * `include/` — заголовочные файлы
   * `tests/` — unit-тесты
   * `build/` — директория для сборки (добавить в `.gitignore`)
4. Основной `CMakeLists.txt` должен:

   * Определять исполняемый файл лабораторной работы
   * Подключать Google Test
   * Создавать отдельную цель для тестов
   * Включать тесты с помощью `enable_testing()` и `add_test()`
   * Поддерживать покрытие тестов с `gcov` и `lcov`
   * Проверять код с `cppcheck`
5. Код должен компилироваться без предупреждений и ошибок при использовании флагов:
   `-Wall -Wextra -Wpedantic -Werror -fsanitize=address -fsanitize=leak`
6. Все зависимости должны загружаться автоматически.

---

## Архитектурные требования

* Все реализации деревьев должны быть шаблонными:
  `Tree<Key, Value, Comparator = DefaultComparator>`.
* Структура узла дерева не должна содержать указатель на родителя.
* Для сравнения ключей использовать передаваемый компаратор, реализованный через паттерн *Стратегия*.
* Реализация должна предоставлять **итераторы** (вперед, reverse при наличии времени) с поддержкой `begin()`, `end()`, `operator*`, `operator++`.
* Все деревья должны использоваться через шаблонный интерфейс `MyMap<Key, Value, TreeType>`:

  ```cpp
  template <typename Key, typename Value, template<typename, typename, typename> class TreeType, typename Comparator = DefaultComparator>
  class MyMap {
      TreeType<Key, Value, Comparator> tree_;
      // интерфейс map-образный
  };
  ```
* Интерфейс `MyMap` должен включать:

  * `insert(const Key&, const Value&)`
  * `find(const Key&) -> Value*`
  * `remove(const Key&)`
  * `contains(const Key&) -> bool`
  * `clear()`
  * `size() const -> size_t`
  * `begin(), end()` — итераторы
* Обходы деревьев реализуются с передачей пользовательского коллбека:

  * `inorder`, `postorder`, `prefix` (если отличен от preorder)

---

## Задание 1. Бинарное дерево поиска (BST)

### Требования:

* Реализовать шаблонный класс бинарного дерева поиска.
* Поддерживать корректные вставку, удаление, поиск и обходы.
* Реализовать итераторы для обхода в порядке `inorder`.
* Реализовать шаблонный класс `MyMap`, использующий данное дерево.
* Покрыть реализацию юнит-тестами.

---

## Задание 2. АВЛ-дерево

### Требования:

* Реализовать шаблонный класс сбалансированного АВЛ-дерева.
* Обеспечить автоматическое поддержание баланса при вставке и удалении.
* Реализовать итераторы и интеграцию с `MyMap`.
* Покрыть реализацию юнит-тестами.

---

## Задание 3. Сплей-дерево

### Требования:

* Реализовать шаблонное сплей-дерево с операцией подъема при доступе.
* Поддерживать интерфейс итераторов.
* Интегрировать дерево в `MyMap`.
* Покрыть реализацию юнит-тестами.

---

## Задание 4. Красно-черное дерево (Red-Black Tree)

### Требования:

* Реализовать шаблонное красно-черное дерево с соблюдением всех инвариантов.
* Обеспечить корректную работу вставки, удаления, поиска и итераторов.
* Подключить дерево к `MyMap`.
* Покрыть реализацию юнит-тестами.

---

## Задание 5. Сравнение производительности

### Требования:

* Провести сравнительный анализ работы `MyMap` с разными реализациями деревьев на входных данных:

  * `10^3`, `10^5`, `10^7` элементов.
* Замерять время на:

  * Вставку всех элементов
  * Поиск всех элементов
  * Удаление всех элементов
* Представить результаты в виде таблицы или графика.

---

### **Рекомендации:**

* Для тестирования использовать `EXPECT_EQ`, `EXPECT_TRUE`, `EXPECT_FALSE`, `EXPECT_THROW` и `TEST_F`.
* Стремиться к покрытию не менее **97%** (`gcov`, `lcov`).
* Для измерения времени использовать `std::chrono`.
* При реализации итераторов использовать стек или родительский контекст, но **не хранить указатель на родителя** в узле.
* Для обходов по коллбекам реализовать передачу универсальной функции (через `std::function`).
* Опционально — реализовать `reverse_iterator`.
